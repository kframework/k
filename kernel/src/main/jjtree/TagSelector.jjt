// Copyright (c) 2013-2020 K Team. All Rights Reserved.
options {
  MULTI=true;
  KEEP_LINE_COLUMN = false;
  STATIC = false;
}
PARSER_BEGIN(TagSelector)
package org.kframework.parser.tagSelector;

import java.lang.String;
import java.io.StringReader;
import java.util.Set;
import java.util.HashSet;
import org.kframework.utils.errorsystem.KEMException;

/**
 * An Arithmetic Grammar.
 * @author Radu Mereuta
 */
public class TagSelector {

  /** Run this to test the parser. */
  public static void main(String args[]) {
    System.out.println("Reading from standard input...");
    TagSelector t = new TagSelector(new StringReader("a|!b&c"));
    try {
      //SimpleNode result = t.ExpressionStart();
      SimpleNode result = t.TagListStart();
      result.dump("");
      System.out.println("Success.");
    } catch (Exception e) {
      System.out.println("Error:");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

  public static Set<String> parseTags(String input) {
    TagSelector t = new TagSelector(new StringReader(input));
    Set<String> tags = new HashSet<String>();
    try {
      ASTTagListStart result = t.TagListStart();
      for (Node n : result.children)
        if (n instanceof SimpleNode)
          tags.add(((SimpleNode) n).value.toString());
    } catch (Exception e) {
      // ignore: e.printStackTrace();
    }
    return tags;
  }

  public static ASTExpressionStart parseSelectorExp(String input) {
    TagSelector t = new TagSelector(new StringReader(input));
    try {
      ASTExpressionStart result = t.ExpressionStart();
      return result;
    } catch (ParseException e) {
      throw KEMException.compilerError("Could not parse " + input + " as a selector expression.", e);
    } catch (TokenMgrError e) {
      throw KEMException.compilerError("Could not parse " + input + " as a selector expression.", e);
    }
  }

  public static boolean eval(Node exp, Set<String> tagList) {
      if (exp instanceof ASTExpressionStart)
          return eval(exp.jjtGetChild(0), tagList);
      else if (exp instanceof ASTOr)
          return eval(exp.jjtGetChild(0), tagList) || eval(exp.jjtGetChild(1), tagList);
      else if (exp instanceof ASTAnd)
          return eval(exp.jjtGetChild(0), tagList) && eval(exp.jjtGetChild(1), tagList);
      else if (exp instanceof ASTNot)
          return !eval(exp.jjtGetChild(0), tagList);
      else if (exp instanceof ASTTag)
          return tagList.contains(((SimpleNode) exp).value.toString());
      throw KEMException.compilerError("Unknown ASTNode type: " + exp.getClass() + " when evaluating selector tags.");
  }
}
PARSER_END(TagSelector)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : /* TAG */
{
  <TAG: (["_","a"-"z","A"-"Z","0"-"9","#","$","%","^","*","+","."])+>
}

/** Main tag list production. */
ASTTagListStart TagListStart() : {}
{
  ("{" ( Tag() )+ "}" | Tag())
  { return jjtThis; }
}

/** Main Expression production. */
ASTExpressionStart ExpressionStart() : {}
{
  Expression()
  { return jjtThis; }
}

void Expression() #void : {}
{
  OrExpression()
}

void OrExpression() #void : {}
{
  ( AndExpression() ("|" OrExpression())? ) #Or(>1) // if it has two elements create an #Or node, otherwise omit it from the ast
}

void AndExpression() #void : {}
{
  ( NotExpression() ("&" AndExpression())? ) #And(>1)
}

void NotExpression() #void : {}
{
  ( "!" UnaryExpression() ) #Not | UnaryExpression()
}

void UnaryExpression() #void : {}
{
  "(" Expression() ")" | Tag()
}

void Tag() :
{ Token t; }
{
  t=<TAG>
  { jjtThis.jjtSetValue(t.image); }
}
