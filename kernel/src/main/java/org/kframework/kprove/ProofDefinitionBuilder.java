package org.kframework.kprove;

import org.apache.commons.io.FilenameUtils;
import org.kframework.compile.Backend;
import org.kframework.definition.Definition;
import org.kframework.definition.Module;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kompile.Kompile;
import org.kframework.utils.Stopwatch;
import org.kframework.utils.errorsystem.KEMException;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import scala.Option;
import scala.Tuple2;

import java.io.File;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * @author Denis Bogdanas
 * Created on 07-Nov-19.
 */
public class ProofDefinitionBuilder {

    private static Map<Definition, Definition>
            cache = Collections.synchronizedMap(new LinkedHashMap<Definition, Definition>() {
        @Override
        protected boolean removeEldestEntry(Map.Entry entry) {
            return size() > 10;
        }
    });

    /**
     * @param specFile           File containing specification rules to prove. Not part of definition.
     * @param defModuleName      Name of main module of extended definition - that is compiled definition + extra
     *                           modules required by proofs, usually abstractions for symbolic execution and lemmas.
     * @param specModuleName     Module containing specifications to prove
     * @param compiledDefinition Definition generated by kompile
     */
    public static Tuple2<Definition, Module> build(File specFile, String defModuleName,
                                                   String specModuleName,
                                                   CompiledDefinition compiledDefinition, Backend backend,
                                                   FileUtil files, KExceptionManager kem, Stopwatch sw) {
        if (defModuleName == null) {
            defModuleName = compiledDefinition.kompiledDefinition.mainModule().name();
        }
        if (specModuleName == null) {
            specModuleName = FilenameUtils.getBaseName(specFile.getName()).toUpperCase();
        }
        File absSpecFile = files.resolveWorkingDirectory(specFile).getAbsoluteFile();

        Kompile kompile = new Kompile(compiledDefinition.kompileOptions, files, kem, sw, true);
        Set<Module> modules = kompile.parseModules(compiledDefinition, defModuleName, absSpecFile,
                backend.excludedModuleTags());
        Map<String, Module> modulesMap = modules.stream().collect(Collectors.toMap(Module::name, m -> m));
        Module defModule = getModule(defModuleName, modulesMap, compiledDefinition.getParsedDefinition());
        Definition rawExtendedDef = Definition.apply(defModule, compiledDefinition.getParsedDefinition().entryModules(),
                compiledDefinition.getParsedDefinition().att());
        Definition compiledExtendedDef = compileDefinition(backend, rawExtendedDef); //also resolves imports

        Module specModule = getModule(specModuleName, modulesMap, compiledDefinition.getParsedDefinition());
        specModule = backend.specificationSteps(compiledDefinition.kompiledDefinition).apply(specModule);

        return Tuple2.apply(compiledExtendedDef, specModule);
    }

    private static Module getModule(String defModule, Map<String, Module> modules, Definition oldDef) {
        if (modules.containsKey(defModule))
            return modules.get(defModule);
        Option<Module> mod = oldDef.getModule(defModule);
        if (mod.isDefined()) {
            return mod.get();
        }
        throw KEMException.criticalError("Module " + defModule + " does not exist.");
    }

    private static Definition compileDefinition(Backend backend, Definition combinedDef) {
        Definition compiled = cache.get(combinedDef);
        if (compiled == null) {
            compiled = backend.steps().apply(combinedDef);
            cache.put(combinedDef, compiled);
        }
        return compiled;
    }
}
