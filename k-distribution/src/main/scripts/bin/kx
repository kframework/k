#!/bin/bash
set -e
set -o pipefail
set -u

export PATH="$(dirname "$0"):$PATH"

ARGV=()
bound=
depth=
color=false
if [ -t 1 ]; then
  color=true
fi
params=()
allPath=true
dir=.
cmd=
cmdprefix=
io=true
filterSubst=true
outputFile=-
pattern=
search=false
searchType=!
term=false
verbose=false
literal=false
outputMode=pretty
flags=
configVars=

tempFiles=()
trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT

input_file="$(mktemp tmp.in.XXXXXXXXXX)"
kore_output="$(mktemp tmp.out.XXXXXXXXXX)"
tempFiles+=("$input_file")
tempFiles+=("$kore_output")

execute () {
  (
  if $verbose; then
    set -x
  fi
  "$@"
  )
}

KX=$(basename "$0")

print_usage () {
cat <<HERE
Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]
Execute a program using a K semantics that was built with kompile.

Mandatory arguments to long options are mandatory for short options too.

$KX expects 0 or 1 positional arguments. If a positional argument is present,
it must be a file and the contents of that file is parsed using the parser
specified with --parser and used as the value of \$PGM (unless --term is
present; see below).

Currently only the LLVM backend is supported. This will change in the near
future.

      --bound N            Return at most N solutions  with --search
      --depth N            Execute at most N rewrite steps
      --color [on|off]     Enable/disable ANSI color codes. Overrides default,
                           which is determined based on whether stdout is a
                           terminal.
  -pNAME=VALUE             Use VALUE as a command to parse \$NAME. For example,
                           if NAME=PGM and VALUE=cat, and the user also passes
                           \`-cPGM=foo\`, a temporary file containing the word
                           "foo" is created and cat is called on it to provide
                           the value of \$PGM as a KORE term.
  
  -cNAME=VALUE             Use VALUE as the value for \$NAME. By default,
                           \`kast -m MAINMODULE -o kore\` is used as the
                           parser. This can be overridden with -p.
      --debugger           Launch the backend in a debugging console.
                           Currently only supported on LLVM backend.
  -d, --directory DIR      Look for a kompiled directory ending in "-kompiled"
                           under the directory DIR.
      --dry-run            Do not execute backend, but instead print the
                           command that would be executed to stdout.
      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke
                                     Haskell backend
  -h, --help               Display this help and exit
      --io [on|off]        Enable/disable reading/writing to actual
                           stdin/stdout via cells with "stream" attribute.
                           Defaults to enabled when performing concrete
                           execution, and disabled when --search is passed.
      --no-substitution-filtering  Don't filter conjuncts with anonymous
                                   variables from substitution output
  -o, --output MODE        Select output mode to use when unparsing. Valid
                           values are pretty, program, kast, binary, json,
                           latex, kore, and none.
      --output-file FILE   Print final configuration to FILE
      --parser VALUE       Use VALUE as parser to parse \$PGM. For example,
                           if the user says "$KX --parser cat foo.kore", then
                           \`cat foo.kore\` is invoked and the result on stdout
                           is used as the value of \$PGM as a KORE term.
      --pattern PAT        Use PAT as the search pattern with --search. Can
                           also be used without --search to match the output
                           configuration against a pattern and print the
                           substitution. Only supported on Haskell backend.
      --save-temps         Do not delete temporary files when $KX terminates.
      --search             Search for all possible output states after
                           rewriting. Only supported on Haskell backend.
      --search-all         Like --search, but also return interim states
      --search-final       Synonym for --search
      --search-one-or-more-steps  Like --search-all, but do not include the
                                  initial state in the result
      --search-one-step    Search for all possible states that are the
                           immediate successor of the input.
      --statistics         Print number of steps executed. Currently only
                           supported on LLVM backend.
      --term               Use the value that would otherwise be considered the
                           value for \$PGM as the entire input configuration.
                           i.e., skip composing configuration from
                           configuration variables.
  -v, --verbose            Print significant commands executed by $KX.
      --version            Print version of K
      --                   Interpret all arguments following as positional
                           arguments.
HERE
}

while [[ $# -gt 0 ]]
do
  arg="$1"
  if $literal; then
    ARGV+=("$1")
  else
    case "$arg" in
      --bound)
      bound="$2"
      shift
      ;;
  
      --depth)
      depth="$2"
      shift
      ;;
  
      --color)
      case "$2" in
        on)
        color=true
        ;;
  
        off)
        color=false
        ;;
  
        *)
        error 'Invalid value for --color. Should be "on" or "off".'
        ;;
      esac
      shift
      ;;
  
      -p*=*)
      keyval=${1#-p}
      key=${keyval%%=*}
      val=${keyval#*=}
      var_name="parser_$key"
      printf -v "$var_name" %s "$val"
      ;;
  
      -c*=*)
      keyval=${1#-c}
      key=${keyval%%=*}
      val=${keyval#*=}
      var_name="config_var_$key"
      params+=("$key")
      tempFile="$(mktemp tmp."$key".pretty.XXXXXXXXXX)"
      tempFiles+=("$tempFile")
      printf %s "$val" > "$tempFile"
      printf -v "$var_name" %s "$tempFile"
      ;;
  
      -d|--directory)
      dir="$2"
      shift
      ;;
  
      --dry-run)
      cmdprefix="echo "
      tempFiles=(${tempFiles[@]/$input_file})
      outputMode=none
      ;;
  
      --haskell-backend-command)
      cmd="$2"
      shift
      ;;
  
      -h|--help)
      print_usage
      exit 0
      ;;
  
      --io)
      case "$2" in
        on)
        io=true
        ;;
  
        off)
        io=false
        ;;
  
        *)
        error 'Invalid value for --io. Should be "on" or "off".'
        ;;
      esac
      shift
      ;;
  
      --no-substitution-filtering)
      filterSubst=false
      ;;
  
      -o|--output)
      case "$2" in
        pretty) ;;
        program) ;;
        kast) ;;
        binary) ;;
        json) ;;
        latex) ;;
        kore) ;;
        none) ;;
        *)
          error 'Invalid value for --output. Should be one of "pretty", "program", "kast", "binary", "json", "latex", "kore", or "none".'
  	;;
      esac
      outputMode="$2"
      shift
      ;;
  
      --output-file)
      outputFile="$2"
      shift
      ;;
  
      --parser)
      var_name="parser_PGM"
      printf -v "$var_name" %s "$2"
      shift
      ;;
  
      --pattern)
      pattern="$2"
      shift
      ;;
  
      --search)
      search=true
      searchType='!'
      ;;
  
      --search-all)
      search=true
      searchType='*'
      ;;
  
      --search-final)
      search=true
      searchType='!'
      ;;
  
      --search-one-or-more-steps)
      search=true
      searchType='+'
      ;;
  
      --search-one-step)
      search=true
      searchType='1'
      ;;
  
      --term)
      term=true
      ;;    
  
      -v|--verbose)
      verbose=true
      flags="$flags -v"
      ;;
  
      -save-temps)
      trap - INT TERM EXIT
      flags="$flags -save-temps"
      ;;
  
      --version)
      kompile --version
      exit 0
      ;;
  
      --debugger)
      cmdprefix="gdb --args "
      ;;
  
      --statistics)
      flags="$flags --statistics"
      ;;
  
      --)
      literal=true
      ;;
  
      -*)
      print_usage
      exit 1
      ;;
  
      *)
      ARGV+=("$1")
      ;;
    esac
  fi
  shift
done

if $search; then
  io=false
fi

if [[ "${#ARGV[@]}" -gt 1 ]]; then
  error 'Cannot pass more than one configuration variable as a positional argument.'
fi

kompiledDir=
hasKompiledDir=false
for file in "$dir"/*-kompiled; do
  kompiledDir=$file
  if $hasKompiledDir; then
    error 'Multiple compiled definitions found in the current working directory: ' "$dir"/*-kompiled
  fi
  hasKompiledDir=true
done

if ! $hasKompiledDir; then
  error 'Could not find a compiled definition. Use --directory to specify one.'
fi

hasArgv=false
if [[ "${#ARGV[@]}" -gt 0 ]]; then
  config_var_PGM="${ARGV[0]}"
  hasArgv=true
  params+=("PGM")
fi

mainModuleName=$(cat "$kompiledDir"/mainModule.txt)

if [ "$outputFile" = "-" ]; then
  outputFile=/dev/stdout
fi

if $term; then
  if [ -z "${parser_PGM+unset}" ]; then
    execute kast -m "$mainModuleName" "$config_var_PGM" -o kore > "$input_file"
  else
    execute $parser_PGM "$config_var_PGM" > "$input_file"
  fi
else
  for name in "${params[@]}"; do
    parser_name="parser_$name"
    config_name="config_var_$name"
    tempFile="$(mktemp tmp.in."$name".XXXXXXXXXX)"
    tempFiles+=("$tempFile")
    sortName=`cat "$kompiledDir"/sort_"$name".txt`
    if [ -z "${!parser_name+unset}" ]; then
      if [ -f "$kompiledDir/parser_$name" ]; then
        parser="$kompiledDir/parser_$name"
      elif [ "$name" = "PGM" ]; then
        if $hasArgv; then
          parser="kast -o kore"
	else
          parser="kast -m $mainModuleName -o kore"
	fi
      else
        parser="kast -m $mainModuleName -o kore"
      fi
    else
      parser="${!parser_name}"
    fi
    execute $parser "${!config_name}" > "$tempFile"
    configVars="$configVars -c $name $tempFile $sortName korefile"
  done
  if [ "$(cat "$kompiledDir"/sort_IO.txt 2>/dev/null)" = "String" ]; then
    if $io; then
      ioText=on
    else
      ioText=off
    fi
    configVars="$configVars -c IO \dv{SortString{}}(\"$ioText\") String kore"
  fi
  if [ "$(cat "$kompiledDir"/sort_STDIN.txt 2>/dev/null)" = "String" ]; then
    if $io; then
      stdinText=
    else
      unescaped=$(</dev/stdin)
      stdinText=$(awk 'BEGIN {for(n=0;n<256;n++)ord[sprintf("%c",n)]=n} {text = text $0 ORS} END {split(text, chars, ""); for (i=1; i<=length(text); i++) { if (chars[i] == "\"") { printf("%s", "\\\"") } else if (chars[i] == "\\") { printf("%s", "\\\\") } else if (chars[i] == "\n") { printf("%s", "\\n") } else if (chars[i] == "\t") { printf("%s", "\\t") } else if (chars[i] == "\r") { printf("%s", "\\r") } else if (chars[i] == "\f") { printf("%s", "\\f") } else if (ord[chars[i]] >= 32 && ord[chars[i]] < 127) { printf("%s", chars[i]) } else { printf("\\x%02x", ord[chars[i]]) } } }' <<< "$unescaped")
    fi
    stdinFile="$(mktemp tmp.stdin.XXXXXXXXXX)"
    tempFiles+=("$stdinFile")
    printf '\dv{SortString{}}(\"%s\")\n' "$stdinText" > "$stdinFile"
    configVars="$configVars -c STDIN $stdinFile String korefile"
  fi
  execute llvm-krun $configVars -d "$kompiledDir" $flags --dry-run -o "$input_file"
fi

if [ -f "$kompiledDir/interpreter" ]; then
  set +e
  execute $cmdprefix "$kompiledDir/interpreter" "$input_file" "${depth:--1}" "$kore_output"
  result=$?
  set -e
else
  error 'Does not yet support Haskell backend.'
fi

case "$outputMode" in
  pretty)
    execute kprint "$kompiledDir" "$kore_output" $color > "$outputFile"
    ;;
  kore)
    cat "$kore_output" > "$outputFile"
    echo >> "$outputFile"
    ;;
  none)
    ;;
  *)
    execute kast -i kore -o "$outputMode" "$kore_output" > "$outputFile"
    ;;
esac

exit $result
